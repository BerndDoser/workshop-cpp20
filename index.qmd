---
title: "The New ISO Standard C++20"
author: "Bernd Doser"
date: July 2022
institute: HITS gGmbH
format:
  revealjs:
    logo: images/HITS_RGB_eng.jpg
    footer: "C++20 (B. Doser)"
    slide-number: true
---

## This presentation is available at{.center}

[https://bernddoser.github.io/workshop-cpp20](https://bernddoser.github.io/workshop-cpp20)


## Agenda

::: {.incremental}
- Warm-up with C++
- Important C++11 features
- C++20 features
  - Concepts, ranges
  - Modules, coroutines
  - std::format, three-way comparison
- Coding competition
:::

<!-- TODO
- Modules
- Concepts
- ISO timeline
- Feature papers
- Programming paradigms
- Meta programming
-->


## My Background

::: {.incremental}
- PhD in theoretical chemistry
  - Linear scaling electron-electron correlation
- C++ scientific software developer since 2004
- Automatic differentiation for tailor-made force fields ([AMS GmbH Freiburg](https://avmatsim.eu/))
- Open source projects @ HITS:
  [GROMACS-FDA](https://github.com/HITS-MBM/gromacs-fda), [GROMACS-RAMD](https://github.com/HITS-MCM/gromacs-ramd), [PINK](https://github.com/HITS-AIN/PINK), [HiFlow3](https://emcl-gitlab.iwr.uni-heidelberg.de/hiflow3.org/hiflow3), [TACO](https://github.com/HITS-TOS/TACO)
- Personal open source projects:
  [BlasBooster](https://github.com/BrainTwister/BlasBooster), [GeneHunter](https://github.com/BrainTwister/GeneHunter)
:::


## Why C++?

::: {layout-ncol=2}
- Multi-paradigm
  - Imperative
  - Object oriented
  - Generic
  - Functional
- Strong type system
- Backward compatibility

![](images/meme-cpp-comple.jpg)
:::


## ISO Standardization

- C++98: First ISO Standard
- C++11: Smart pointers, move sematic, Lambda functions, range-based for loop, auto
- C++14: Variable templates, generic lambdas
- C++17: Structured bindings
- C++20: Modules, concepts, coroutines, ranges
- Suggestions for C++23: "A plan for ranges", reflections


## Books and ISO Standard

::: columns
::: {.column width="60%"}
![](images/book_stroustrup.jpg){.border width="180" height="250"}
![](images/book_josuttis.jpg){.border width="180" height="250"}
![](images/book_gottschling.jpg){.border width="180" height="250"}
![](images/book_vandevoorde.jpg){.border width="180" height="250"}
![](images/book_cukic.jpg){.border width="180" height="250"}
![](images/book_grimm.jpg){.border width="180" height="250"}
:::

::: {.column width="40%"}
- C++20 ISO Standard: ISO/IEC 14882:2020
  - Commercial version ~200 EUR
  - [Free working draft](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/n4849.pdf)
:::
:::

::: notes
- Show ranges concept
:::


## Helpful Links and Tools

::: {layout-ncol=2}
- [cppreference.com](https://cppreference.com)
- [CompilerExplorer](https://gcc.godbolt.org)
- [C++ Core Guidelines](https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines)

![](images/compiler_explorer.png)
:::


## C++98 Warm-up

```{.cpp}
class Matrix
{
public:

    Matrix(int m, int n)
     : m(m), n(n), mat(m*n)
    {}

    Matrix operator * (Matrix B) {
        Matrix C(this->m, B.n);
        /* C(i,j) = sum_k A(i,k) * B(k,j) */
        return C;
    }

private:
    int m,n;
    std::vector<double> mat;
};
```

[CompilerExplorer](https://godbolt.org/z/cbbEbYcr9)


## Carbage Collection vs. RAII

::: {.callout-note icon=false}
## Carbage Collection (Java, Python, Go)

- Automatic memory management, which periodically stops all threads and frees unreferenced memory.
- Extra overhead
:::

::: {.callout-note icon=false}
## RAII: Resource Aquisition is Initialization (C++, Rust)

- The lifetime of a resource will be bound to the lifetime of a local variable. C++ automatically manages the lifetime of locals.
- Smart pointers (C++11) overcome the manually memory deallocation.

C++ principle: "Don't pay for something you don't use."
:::


## Raw pointers (before C++11)

- Manual allocation and deallocation of memory
  - Segmentation faults
  - Memory leaks

```{.cpp}
void func()
{
    int* valuePtr = new int(42);
    if ( /* ... */ ) return; // memory leak
    delete valuePtr;
}
```
::: {.callout-note}
Raw pointers (`new`) are deprecated in C++20 and will be removed in C++23.
:::


## Smart pointers (C++11)

```{.cpp}
#include <memory>
 
void func()
{
    std::shared_ptr<int> valuePtr(new int(42));

    if ( /* ... */ )
        return;   // no memory leak
}
```
Better:
```{.cpp}
std::shared_ptr<A> ptrA = std::make_shared<A>();
```
Best:
```{.cpp}
auto ptrA = std::make_shared<A>();
```

## Smart pointers (C++11)

::: {.callout-note icon=false}
## `std::unique_ptr<T>`
- Allows exactly one owner of the underlying pointer
- Can be moved to a new owner, but not copied or shared
:::

::: {.callout-note icon=false}
## `std::shared_ptr<T>`
- Reference-counted smart pointer
- The raw pointer is not deleted until all owners have gone out of scope
:::

::: {.callout-note icon=false}
## `std::weak_ptr<T>`
- Required to break circular references between `shared_ptr`
:::


## Smart pointers (C++11)

```{.cpp code-line-numbers="1-4|6-10|1,12-17"}
    auto p1 = std::make_shared<int>(1);
    auto p2 = p1;
    assert(*p2 == 1);
    assert(p1.use_count() == 2);

    auto p3 = std::make_unique<int>(2);
    // auto p4 = p3;   // unique_ptr can't be copied
    auto p5 = std::move(p3);
    assert(*p5 == 2);
    assert(p3 == nullptr);

    // auto p6 = std::weak_ptr<int>(3);  // weak_ptr can't own
    auto p6 = std::weak_ptr<int>(p1);
    assert(p6.use_count() == 2);
    p1.reset();
    p2.reset();
    assert(p6.expired());
```
[CompilerExplorer](https://godbolt.org/z/dErqbrYM4)


## Move Semantics (C++11)

:::{.callout-tip icon=false}
## L-values will be copied
- Permanent objects with a name and a storage address
- Copy is expensive
:::

:::{.callout-tip icon=false}
## R-values will be moved
- Temporary objects without a name and a storage address
- R-values can only appear on the right side in an assignment
- Move is fast
:::

```{.cpp}
int i = 5;
std::string s = "foo";
double c = a * b;
double y = function(x);
```


## Containers

| Name             | Description                           |
|------------------|---------------------------------------|
| `array`          | static contiguous array               |
| `vector`         | dynamic contiguous array              |
| `list`           | linked list                           |
| `set`            | sorted collection of unique keys      |
| `map`            | sorted collection of key-value pairs  |
| `unordered_set`  | hashed collection of unique keys      |
| `unordered_map`  | hashed collection of key-value pairs  |


## C++20: New Keywords

::: columns
::: {.column width="50%"}
- Concepts
  - `concept`
  - `requires`

- Coroutines
  - `co_await`
  - `co_return`
  - `co_yield`
:::

::: {.column width="50%"}
- Modules
  - `import`
  - `module`

- Others
  - `constinit`
  - `consteval`
  - `char8_t`
:::
:::


## Modules

- Modules are a new way to organize C++ code into logical components
- Problems of the obsolete header files
  - Repetitive compilation of the same code
  - Inclusion order-dependent headers
  - Cyclic dependencies
  - Macros leakage in and out from headers
  - Poor encapsulation of implementation details


## Modules

```{.cpp}
// math.cppm
export module math;

export int add(int fir, int sec)
{
    return fir + sec;
}

// client.cpp
import math;

int main()
{
   add(2000, 20);
}
```


## Coroutines: Evolution of Functions

```{.cpp}
int f1() { return 1; } // A C-like function

int f2(int arg) { return arg; } // Function overloading
double f2(double arg) { return arg; }

template <typename T> // Function template
T f3(T arg) { return arg; }

struct F4 { // Functor
    int operator()() { return 4; }
};

auto f5 = [] { return 5; }; // Lambda (C++11)

auto f6 = [] (auto arg) { return arg; }; // Generic lambda (C++14)
```


## Coroutines

- A coroutine is a generalisation of a function that allows the function to be suspended and then later resumed.
- A coroutine is stackless: their state is stored in heap, not on stack
- A coroutine contains one of these keywords:
  - `co_return` (coroutine return statement)
  - `co_await` (await expression)
  - `co_yield` (yield expression)


## Coroutines and CppCoro

Coroutines provides a very low-level interface. [CppCoro](https://github.com/lewissbaker/cppcoro) is an experimental library that is exploring the space of high-performance, scalable asynchronous programming abstractions

- task<T>: asynchronous computation that is executed lazily
- generator<T>: a coroutine type that produces a sequence of values of type `T` where values are produced lazily and synchronously.


## Concepts

- With concepts, failure happens early and the error message is much more meaningful.

Before C++20 `enable_if` was used to check template arguments. Substitution failure is not an error (SFINAE)
```{.cpp}
// C++11
template <typename T>
std::enable_if_t<std::is_same_v<T, int>> f(T x);
 
// C++20
void f(std::same_as<int> auto x);
```


## Concepts: Example

- Definition
```{.cpp}
template <typename T>
concept Incrementable = requires(T x) { x++; ++x; };
```
- Usage
```{.cpp}
template <Incrementable T>
void inc(T t);

template <Incrementable T>
void inc(T t) requires Incrementable<T>;

void inc(Incrementable auto t);
```


## The World Before Ranges (C++11)

```{.cpp}
#include <algorithm>
 
int main()
{
    std::vector<int> data{42, 1, 12, -3, 14, -5};
    std::vector<int> pos;

    // copy only positive numbers:
    std::copy_if(data.begin(), data.end(),
      std::back_inserter(pos), [](int i){return i >= 0;} );
}
```
[cppreference std::copy_if](https://en.cppreference.com/w/cpp/algorithm/copy)

```{.cpp}
template <class InputIt, class OutputIt, class UnaryPredicate>
OutputIt copy_if( InputIt first, InputIt last,
                  OutputIt d_first,
                  UnaryPredicate pred );
```

[CompilerExplorer](https://gcc.godbolt.org/z/7EMhaWd5q)


## Ranges: What We Want

- Direct usage of containers without iterators (pointers)
```{.cpp}
std::vector<int> v{1,2,3};
std::sort(std::begin(v), std::end(v));
std::ranges::sort(v);
```
- Chaining-like unix pipes
```{.cpp}
result = data | func1 | func2 | ...
```
- Lazy evaluation


## Ranges: filter

```{.cpp}
#include <ranges>
#include <vector>
 
int main()
{
    std::vector<int> data{42, 1, 12, -3, 14, -5};
    auto even = [](int i){return i >= 0;};

    auto pos = data | std::views::filter(even);
}
```
[CompilerExplorer](https://gcc.godbolt.org/z/T5W6K46Gb)


## Ranges: How it works

- A `range` is a concept, not a container
- Defined in header `<ranges>`:
```{.cpp}
template < class T >
concept range = requires( T& t ) {
  ranges::begin(t);
  ranges::end(t);
};
```
::: {.smaller}
[cppreference std::ranges](https://en.cppreference.com/w/cpp/ranges/range)
:::

:::{.callout-note}
Why `std::begin(t)` instead of `t.begin()`?
:::


## Ranges: views

:::{.callout-tip icon=false}
## Eric Niebler
"Views are composable adaptations of ranges where the adaptation happens lazily as the view is iterated."
:::

```{.cpp}
template<class D>
  requires std::is_class_v<D> && std::same_as<D, std::remove_cv_t<D>>
class view_interface;
```

`view_interface` is typically used with CRTP

```{.cpp}
class my_view : public std::ranges::view_interface<my_view> {
public:
    auto begin() const { /*...*/ }
    auto end() const { /*...*/ }
};
```


## Ranges: Pipelining

```{.cpp}
C(B)
B | C
```
- Views can be chained by overloading the `operator|`
  (see [CompilerExplorer](https://godbolt.org/z/7hvYnrbWa)).

```{.cpp}
auto const data = {0, 1, 2, 3, 4, 5};
auto even = [](const auto& v) { return 0 ## v % 2; };
auto square = [](const auto& v) { return v * v; };

// "pipe" syntax of composing the views:
auto result { data
    | std::views::filter(even)
    | std::views::transform(square)
    | std::views::drop(2)
    | std::views::reverse
    | std::views::transform([](const auto& v){ return std::to_string(v); }) };
```


## Ranges: Lazy evaluation




## Ranges: filter and transform

```{.cpp}
#include <ranges>
#include <iostream>
 
int main()
{
    auto const ints = {0,1,2,3,4,5};
    auto even = [](int i) { return 0 ## i % 2; };
    auto square = [](int i) { return i - i; };
 
    // "pipe" syntax of composing the views:
    for (int i : ints | std::views::filter(even) | std::views::transform(square)) {
        std::cout << i << ' ';
    }
 
    std::cout << '\n';
 
    // a traditional "functional" composing syntax:
    for (int i : std::views::transform(std::views::filter(ints, even), square)) {
        std::cout << i << ' ';
    }
}
```


## Text Formating

- 

```{.cpp}
#include <fmt/core.h>

int main()
{
    fmt::print("Hello, world!\n");
}
```
[CompilerExplorer](https://gcc.godbolt.org/z/xoTEjdT68)


## Three-way comparison

- Comparison operators
  - `==`, `!=` 
  - `<`, `>`, `<=`, `>=`
- Usually `==` and `<` contain the real logic and the others

Example:
```{.cpp}
struct Point
{
    int x;
    int y;
};
```

::: notes
- Write a 2-dim. point class with all comparison operators
- Write same class with spaceship operator
:::


## Three-way comparison

```{.cpp}
struct Point
{
    int x,y;

    frind bool operator == (const Point& a, const Point& b) {
      return a.x == b.x and a.y == b.y; }
    frind bool operator <  (const Point& a, const Point& b) {
      return a.x < b.x or (a.x == b.x and a.y < b.y); }
    frind bool operator != (const Point& a, const Point& b) {
      return !(a==b); }
    frind bool operator <= (const Point& a, const Point& b) {
      return !(b<a); }
    frind bool operator >  (const Point& a, const Point& b) {
      return b<a; }
    frind bool operator >= (const Point& a, const Point& b) {
      return !(a<b); }
};
```


## Coding competition

Source: [GoogleCodeJam](https://codingcompetitions.withgoogle.com/codejam)

2016 Quali Round Problem B: Revenge of the Pancakes

Stack of pancakes with a happy face made of chocolate on one side '+' and nothing on the other side '-'. Goal is to have all pancakes with the happy side on the top.

[CompilerExplorer](https://godbolt.org/z/61fede6sr)


## Solution

```{.cpp}
std::string stack{"++--+-"};

auto flip = [](const char c){
  return c == '+' ? '-' : '+';   // Conditional/Ternary operator
};

int n = 0;
for (auto first = std::ranges::find(stack, '-'); first != std::end(stack);
     first = std::ranges::find(stack, '-'), n++)
{
  if (stack[0] == '+') {
    auto sub = std::ranges::subrange(std::begin(stack), first);
    std::ranges::transform(sub, std::begin(sub), flip);
  } else {
    auto first_happy = std::ranges::find(stack, '+');
    auto sub = std::ranges::subrange(std::begin(stack), first_happy);
    std::ranges::transform(sub, std::begin(sub), flip);
  }
}
std::cout << "You need " << n << " flips to make all happy." << std::endl;
```


## Summary

- C++ is going 

## Thank you {.center}

https://bernddoser.github.io/workshop-cpp20

