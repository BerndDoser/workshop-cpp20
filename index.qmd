---
title: "The new ISO Standard C++20"
author: "Bernd Doser"
date: July 2022
institute: HITS gGmbH
format:
  revealjs:
    logo: images/HITS_RGB_eng.jpg
    footer: "C++20 (B. Doser)"
    slide-number: true
---

## Who am I?

::: {.incremental}
- Scientific software developer since 15 years
- PhD in theoretical chemistry
- Linear scaling electron-electron correlation
- Tailor-made force fields
- [BlasBooster](https://github.com/BrainTwister/BlasBooster){.link-external-newwindow}
- [GROMACS-FDA](https://github.com/HITS-MBM/gromacs-fda), [GROMACS-RAMD](https://github.com/HITS-MCM/gromacs-ramd)
- [PINK](https://github.com/HITS-AIN/PINK)
- [HiFlow3](https://emcl-gitlab.iwr.uni-heidelberg.de/hiflow3.org/hiflow3)
- TACO
:::


## Outline

::: {.incremental}
- Introduction
- New features of C++20
  - Modules
  - Concepts
  - Coroutines
  - Ranges
  - std::format
  - Three-way comparison
:::


## Introduction

Bjarne Stroustrup developed "C with classes", which introduces the class concept of "Simula" with data encapsulation into C.

- Strong type system
- Backward compatibility


## ISO Standardization

- C++98: First ISO Standard
- C++11: Smart pointers, Move sematic, Lambda functions, range-based for loop, auto
- C++14: variable templates, generic lambdas
- C++17: Structured bindings
- C++20: Modules, Concepts, Coroutines, Ranges
- C++23: A Plan for Ranges, Reflections?


## Books and ISO Standard

::: columns
::: {.column width="60%"}
![](images/book_stroustrup.jpg){.border width="180" height="250"}
![](images/book_josuttis.jpg){.border width="180" height="250"}
![](images/book_gottschling.jpg){.border width="180" height="250"}
![](images/book_vandevoorde.jpg){.border width="180" height="250"}
![](images/book_cukic.jpg){.border width="180" height="250"}
![](images/book_grimm.jpg){.border width="180" height="250"}
:::

::: {.column width="40%"}
- C++20 ISO Standard: ISO/IEC 14882:2020
  - Commercial version ~200 EUR
  - [Free working draft](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/n4849.pdf)
:::
:::

::: notes
- Show ranges concept
:::

## Helpful Links

- [cppreference.com](https://cppreference.com)
- [CompilerExplorer](https://gcc.godbolt.org)
- [C++ Core Guidelines](https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines)


## Carbage collection vs. RAII

::: {.callout-note icon=false}
## Carbage collection (Java, Python, Go)

- Automatic memory management, which periodically stops all threads and free unreferenced memory.
- Extra overhead
:::

::: {.callout-note icon=false}
## RAII: Resource Aquisition is Initialization (C++, Rust)

- The lifetime of a resource will be bound to the lifetime of a local variable. C++ automatically manages the lifetime of locals.
- Smart pointers (C++11) overcome the manually memory deallocation.

C++ principle: "Don't pay for something you don't use."
:::


## Raw pointers (before C++11)

- Manual allocation and deallocation of memory
  - Segmentation faults
  - Memory leaks

```{.cpp}
void func()
{
    int* valuePtr = new int(42);

    if ( /* ... */ )
        return;   // memory leak

    delete valuePtr;
}
```


## Smart pointers (C++11)

```{.cpp}
#include <memory>
 
void func()
{
    std::shared_ptr<int> valuePtr(new int(42));

    if ( /* ... */ )
        return;   // no memory leak
}
```
Better usage:
```{.cpp}
std::shared_ptr<A> ptrA = std::make_shared<A>();
auto ptrA = std::make_shared<A>();
```

## Smart pointers (C++11)

::: {.callout-note icon=false}
## `std::unique_ptr<T>`
- Allows exactly one owner of the underlying pointer
- Can be moved to a new owner, but not copied or shared
:::

::: {.callout-note icon=false}
## `std::shared_ptr<T>`
- Reference-counted smart pointer
- The raw pointer is not deleted until all owners have gone out of scope
:::

::: {.callout-note icon=false}
## `std::weak_ptr<T>`
- Required to break circular references between `shared_ptr`
:::


## Smart pointers (C++11)

```{.cpp code-line-numbers="1-4|6-10|1,12-17"}
    auto p1 = std::make_shared<int>(1);
    auto p2 = p1;
    assert(*p2 == 1);
    assert(p1.use_count() == 2);

    auto p3 = std::make_unique<int>(2);
    // auto p4 = p3;   // unique_ptr can't be copied
    auto p5 = std::move(p3);
    assert(*p5 == 2);
    assert(p3 == nullptr);

    // auto p6 = std::weak_ptr<int>(3);  // weak_ptr can't own
    auto p6 = std::weak_ptr<int>(p1);
    assert(p6.use_count() == 2);
    p1.reset();
    p2.reset();
    assert(p6.expired());
```
[CompilerExplorer](https://godbolt.org/z/dErqbrYM4)

## Containers

| Name             | Description                           |
|------------------|---------------------------------------|
| `array`          | static contiguous array               |
| `vector`         | dynamic contiguous array              |
| `list`           | linked list                           |
| `set`            | sorted collection of unique keys      |
| `map`            | sorted collection of key-value pairs  |
| `unordered_set`  | hashed collection of unique keys      |
| `unordered_map`  | hashed collection of key-value pairs  |


## C++20: New Keywords

::: columns
::: {.column width="50%"}
- Concepts
  - `concept`
  - `requires`

- Coroutines
  - `co_await`
  - `co_return`
  - `co_yield`
:::

::: {.column width="50%"}
- Modules
  - `import`
  - `module`

- Others
  - `constinit`
  - `consteval`
  - `char8_t`
:::
:::


## Modules

- Problems of the header files
  - macros leakage in and out from headers
  - inclusion-order-dependent headers
  - repetitive compilation of the same code
  - cyclic dependencies
  - poor encapsulation of implementation details

```{.cpp}
export module math;

export int add(int fir, int sec)
{
    return fir + sec;
} 
```


## Evolution of Functions

```{.cpp}
int f1() { return 1; } // A C-like function

int f2(int arg) { return arg; } // Function overloading
double f2(double arg) { return arg; }

template <typename T> // Function template
T f3(T arg) { return arg; }

struct F4 { // Functor
    int operator()() { return 4; }
};

auto f5 = [] { return 5; }; // Lambda (C++11)

auto f6 = [] (auto arg) { return arg; }; // Generic lambda (C++14)
```


## Coroutines

A function is a coroutine if it contains one of these:

- `co_return` (coroutine return statement)
- `co_await` (await expression)
- `co_yield` (yield expression)

- Task
- Generator


## Concepts

- With concepts failure happens early and the error message is much cleaner.

Before C++20 `enable_if` was used to check template arguments.Substitution failure is not an error (SFINAE)
```{.cpp}
// C++11
template <typename T>
std::enable_if_t<std::is_same_v<T, int>> f(T x);
 
// C++20
void f(std::same_as<int> auto x);
```


## Concepts: Example

- Definintion
```{.cpp}
template <typename T>
concept Incrementable = requires(T x) { x++; ++x; };
```
- Usage
```{.cpp}
template <Incrementable T>
void inc(T t);

template <Incrementable T>
void inc(T t) requires Incrementable<T>;

void inc(Incrementable auto t);
```


## The world before ranges (C++11)

```{.cpp}
#include <algorithm>
 
int main()
{
    std::vector<int> data{42, 1, 12, -3, 14, -5};
    std::vector<int> pos;

    // copy only positive numbers:
    std::copy_if(data.begin(), data.end(),
      std::back_inserter(pos), [](int i){return i >= 0;} );
}
```
[cppreference std::copy_if](https://en.cppreference.com/w/cpp/algorithm/copy)

```{.cpp}
template <class InputIt, class OutputIt, class UnaryPredicate>
OutputIt copy_if( InputIt first, InputIt last,
                  OutputIt d_first,
                  UnaryPredicate pred );
```

[CompilerExplorer](https://gcc.godbolt.org/z/7EMhaWd5q)


## Ranges: What we want

- Direct usage of containers without iterators (pointers)
- Chaining like unix pipes
- Lazy evaluation

::: {.callout}
`result = data | func1 | func2 | ...`
:::

## Ranges: filter

```{.cpp}
#include <ranges>
#include <vector>
 
int main()
{
    std::vector<int> data{42, 1, 12, -3, 14, -5};
    auto even = [](int i){return i >= 0;};

    auto pos = data | std::views::filter(even);
}
```
[CompilerExplorer](https://gcc.godbolt.org/z/T5W6K46Gb)


## Ranges: How it works

- A `range` is a concept, not a container
- Defined in header `<ranges>`:
```{.cpp}
template < class T >
concept range = requires( T& t ) {
  ranges::begin(t);
  ranges::end(t);
};
```
::: {.smaller}
[cppreference std::ranges](https://en.cppreference.com/w/cpp/ranges/range)
:::

:::{.callout-note}
Why `std::begin(t)` instead of `t.begin()`?
:::


## Ranges: views

:::{.callout-tip icon=false}
## Eric Niebler
"Views are composable adaptations of ranges where the adaptation happens lazily as the view is iterated."
:::

```{.cpp}
template<class D>
  requires std::is_class_v<D> && std::same_as<D, std::remove_cv_t<D>>
class view_interface;
```

`view_interface` is typically used with CRTP

```{.cpp}
class my_view : public std::ranges::view_interface<my_view> {
public:
    auto begin() const { /*...*/ }
    auto end() const { /*...*/ }
};
```


## Ranges: Pipelining

::: {.center}
C(B)

B | C
:::


## Ranges: Lazy evaluation




## Ranges: filter and transform

```{.cpp}
#include <ranges>
#include <iostream>
 
int main()
{
    auto const ints = {0,1,2,3,4,5};
    auto even = [](int i) { return 0 ## i % 2; };
    auto square = [](int i) { return i - i; };
 
    // "pipe" syntax of composing the views:
    for (int i : ints | std::views::filter(even) | std::views::transform(square)) {
        std::cout << i << ' ';
    }
 
    std::cout << '\n';
 
    // a traditional "functional" composing syntax:
    for (int i : std::views::transform(std::views::filter(ints, even), square)) {
        std::cout << i << ' ';
    }
}
```


## std::format

```{.cpp}
#include <fmt/core.h>

int main()
{
    fmt::print("Hello, world!\n");
}
```
[CompilerExplorer](https://gcc.godbolt.org/z/xoTEjdT68)


## Three-way comparison

- Comparison operators
  - `==`, `!=` 
  - `<`, `>`, `<=`, `>=`
- Usually `==` and `<` contain the real logic and the others

Example:
```{.cpp}
struct Point
{
    int x;
    int y;
};
```

::: notes
- Write a 2-dim. point class with all comparison operators
- Write same class with spaceship operator
:::


## Three-way comparison

```{.cpp}
struct Point
{
    int x,y;

    frind bool operator == (const Point& a, const Point& b) {
      return a.x == b.x and a.y == b.y; }
    frind bool operator <  (const Point& a, const Point& b) {
      return a.x < b.x or (a.x == b.x and a.y < b.y); }
    frind bool operator != (const Point& a, const Point& b) {
      return !(a==b); }
    frind bool operator <= (const Point& a, const Point& b) {
      return !(b<a); }
    frind bool operator >  (const Point& a, const Point& b) {
      return b<a; }
    frind bool operator >= (const Point& a, const Point& b) {
      return !(a<b); }
};
```


## Coding competition

Source: [GoogleCodeJam](https://codingcompetitions.withgoogle.com/codejam)

2016 Quali Round Problem B: Revenge of the Pancakes

Stack of pancakes with a happy face made of chocolate on one side '+' and nothing on the other side '-'. Goal is to have all pancakes with the happy side on the top.

[CompilerExplorer]()

## Thank you {.center}

https://bernddoser.github.io/workshop-cpp20


## TODO

- ISO timeline
- Feature papers
- Programming paradigms
- Move sematic
- Meta programming
