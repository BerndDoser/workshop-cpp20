= C++20

:imagesdir: images
:icons: font
:date: June, 2022
:my_name: Bernd Doser
:my_email: bernd.doser@h-its.org
:my_twitter: BerndDoser
:my_github: BerndDoser
:revealjs_slideNumber: true
:revealjs_center: false
:revealjs_width: 1400
:revealjs_height: 800
:customcss: custom.css
:source-highlighter: rouge
:highlightjs-theme: a11y-dark.css
:highlightjs-languages: cpp

mailto:{my_email}[{my_name}]

{date}

image:ISO_C++_Logo.svg[background,size=cover]
image:HITS_RGB_eng.jpg[float="right",link=https://h-its.org,width=40%,role=external,window=_blank]

https://twitter.com/{my_twitter}[icon:twitter[]] https://github.com/{my_github}[icon:github[]]


== Who am I?

//[%step]
* Scientific software developer since 15 years
* PhD in theoretical chemistry
* Linear scaling electron-electron correlation
* Tailor-made force fields
* https://github.com/BrainTwister/BlasBooster[BlasBooster,role=external,window=_blank]
* https://github.com/HITS-MBM/gromacs-fda[GROMACS-FDA,role=external,window=_blank], https://github.com/HITS-MCM/gromacs-ramd[GROMACS-RAMD,role=external,window=_blank]
* https://github.com/HITS-AIN/PINK[PINK,role=external,window=_blank]
* https://emcl-gitlab.iwr.uni-heidelberg.de/hiflow3.org/hiflow3[HiFlow3,role=external,window=_blank]


== Outline

//[%step]
* Introduction
* New features
** Modules
** Concepts
** Coroutines
** Ranges
** std::format
** Spaceship operator <=>


== Introduction

Bjarne Stroustrup developed "C with classes", which introduces the class concept of "Simula" with data encapsulation into C.

* Strong type system
* Backward compatibility

== ISO Standardization

* C++98: First ISO Standard
* C++11: Smart pointers, Move sematic, Lambda functions, range-based for loop, auto
* C++14: variable templates, generic lambdas
* C++17: 
* C++20: Modules, Concepts, Coroutines, Ranges
* C++23: A Plan for Ranges, Reflections?

== Books and ISO Standard

image:book_stroustrup.jpg[height=300]
image:book_josuttis.jpg[height=300]
//image:book_williams.jpg[height=300]
//image:book_meyers.jpg[height=300]
image:book_gottschling.jpg[height=300]
image:book_vandevoorde.jpg[height=300]

[%step]
* C++20 ISO Standard: ISO/IEC 14882:2020
** Commercial version ~200 EUR
** https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/n4849.pdf[Free working draft]


== Helpful links

* https://cppreference.com[cppreference.com,role=external,window=_blank]

* https://gcc.godbolt.org[CompilerExplorer,role=external,window=_blank]

* https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines[C++ Core Guidelines,role=external,window=_blank]


[.columns]
== New keywords

[.column]
* concept
* requires
* co_await
* co_return
* co_yield

[.column]
* import
* module
* constinit
* consteval
* char8_t

== Modules

* Replace header files


== Concepts

[source, cpp]
----
// C++11/14, SFINAE (sub)
template <typename T>
std::enable_if_t<std::is_same_v<T, int>> f(T x);
 
// C++20: concepts
void f(std::same_as<int> auto x);
----


== Evolution of Functions

[source, cpp]
----
int f1() { return 1; } // A C-like function

int f2(int arg) { return arg; } // Function overloading
double f2(double arg) { return arg; }

template <typename T> // Function template
T f3(T arg) { return arg; }

struct F4 { // Functor
    int operator()() { return 4; }
};

auto f5 = [] { return 5; }; // Lambda (C++11)

auto f6 = [] (auto arg) { return arg; }; // Generic lambda (C++14)
----

== Coroutines

* Generator

[.notes]
--
https://mariusbancila.ro/blog/2020/06/22/a-cpp20-coroutine-example/
--


== Ranges

* Defined in header <ranges>
+
[source, cpp]
----
template< class T >
concept range = requires( T& t ) {
  ranges::begin(t); // equality-preserving for forward iterators
  ranges::end  (t);
};
----
* std::begin(t) instead of t.begin()


== Ranges: views

TIP: "Views are composable adaptations of ranges where the adaptation happens lazily as the view is iterated." (Eric Niebler)


== Range: pipe

[source, cpp]
----
C(B)
B | C
----


== Ranges: filter and transform
[source, cpp]
----
#include <ranges>
#include <iostream>
 
int main()
{
    auto const ints = {0,1,2,3,4,5};
    auto even = [](int i) { return 0 == i % 2; };
    auto square = [](int i) { return i * i; };
 
    // "pipe" syntax of composing the views:
    for (int i : ints | std::views::filter(even) | std::views::transform(square)) {
        std::cout << i << ' ';
    }
 
    std::cout << '\n';
 
    // a traditional "functional" composing syntax:
    for (int i : std::views::transform(std::views::filter(ints, even), square)) {
        std::cout << i << ' ';
    }
}
----


== std::format

[source, cpp]
----
#include <fmt/core.h>

int main()
{
    fmt::print("Hello, world!\n");
}
----

https://gcc.godbolt.org/z/xoTEjdT68[CompilerExplorer]


== Spaceship operator <=>

* Comparing 2 objects
a > b, a < b, a == b

[source, cpp]
----

----

[.notes]
--
* Write point class with all comparison operators
* Compile with makefile
* Write same class with spaceship operator
--


== Carbage collection vs. RAII

* Carbage collection (Java, Python, Go)
+
Automatic memory management, which periodically stops all threads and free unreferenced memory. Extra overhead

TIP: C++ principle: "Don't pay for something you don't use."

* RAII: Resource Aquisition is Initialization (C++, Rust)
+
The lifetime of a resource will be bound to the lifetime of a local variable. C++ automatically manages the lifetime of locals.
Smart pointers ('C++11') overcome the manually memory deallocation.


== Smart pointers

* Raw pointer (before C++11)
+
[source, cpp]
----
{
    Molecule* ptrMolecule = new Molecule("c1ccccc1");
    calculateEnergy(ptrMolecule);
    delete molecule;
}
----
** Segmentation fault if ptrMolecule is deleted within calculateEnergy.

* Smart pointer (C++11)
+
[source, cpp]
----
{
    std::unique_ptr<Molecule> ptrMolecule(new Molecule("c1ccccc1"));
    calculateEnergy(ptrMolecule);
} // ptrMolecule is deleted automatically here.
----
** Copy of raw pointer not defined, only construction.


== Smart pointers

* std::unique_ptr<T>
** Allows exactly one owner of the underlying pointer
** Can be moved to a new owner, but not copied or shared

* std::shared_ptr<T>
** Reference-counted smart pointer
** The raw pointer is not deleted until all owners have gone out of scope

* std::weak_ptr<T>
** Special-case smart pointer for use in conjunction with shared_ptr
** Required to break circular references between shared_ptr


== Thank you 

https://bernddoser.github.io/workshop-cpp20

